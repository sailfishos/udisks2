From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bj=C3=B6rn=20Bidar?= <bjorn.bidar@jolla.com>
Date: Thu, 7 Dec 2017 13:15:34 +0200
Subject: [PATCH] Make libatasmart support optional
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Bj√∂rn Bidar <bjorn.bidar@jolla.com>
---
 configure.ac              | 17 ++++++++++++++---
 src/udiskslinuxdriveata.c | 15 +++++++++++++++
 2 files changed, 29 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index 69c43ee7..e4b56e93 100644
--- a/configure.ac
+++ b/configure.ac
@@ -172,9 +172,19 @@ if test "x$enable_daemon" = "xyes"; then
   AC_SUBST(BLOCKDEV_CFLAGS)
   AC_SUBST(BLOCKDEV_LIBS)
 
-  PKG_CHECK_MODULES(LIBATASMART, [libatasmart >= 0.17])
-  AC_SUBST(LIBATASMART_CFLAGS)
-  AC_SUBST(LIBATASMART_LIBS)
+  AC_ARG_ENABLE(libata, AS_HELP_STRING([--enable-libatasmart], [enable libatasmart support]))
+  AS_IF([test "x$enable_libatasmart" != "xno"],
+      [PKG_CHECK_MODULES(LIBATASMART, [libatasmart >= 0.17],
+      [
+        AC_SUBST(LIBATASMART_CFLAGS)
+        AC_SUBST(LIBATASMART_LIBS)
+        AC_DEFINE([HAVE_ATA_SMART], 1, [Define to 1 if libatasmart is enabled])
+        have_libatasmart=yes
+      ],
+      [AS_IF([test "x$enable_libata" = "xyes"],
+             [AC_MSG_ERROR([libatasmart requested but not found])
+      ])
+      ])])
 
   PKG_CHECK_MODULES(LIBBLKID, [blkid])
   AC_SUBST(LIBBLKID_CFLAGS)
@@ -692,6 +702,7 @@ echo "
         using libsystemd-login:     ${have_libsystemd_login}
         using libelogind:           ${have_libelogind}
         use /media for mounting:    ${fhs_media}
+        libatasmart:                ${have_libatasmart:-no}
         acl support:                ${have_acl}
 
         compiler:                   ${CC}
diff --git a/src/udiskslinuxdriveata.c b/src/udiskslinuxdriveata.c
index b86c3465..33d3efc5 100644
--- a/src/udiskslinuxdriveata.c
+++ b/src/udiskslinuxdriveata.c
@@ -37,7 +37,9 @@
 #include <glib/gstdio.h>
 #include <errno.h>
 
+#ifdef HAVE_ATA_SMART
 #include <atasmart.h>
+#endif
 
 #include "udiskslogging.h"
 #include "udiskslinuxprovider.h"
@@ -357,6 +359,7 @@ typedef struct
   gint num_attributes_failed_in_the_past;
 } ParseData;
 
+#ifdef HAVE_ATA_SMART
 static void
 parse_attr_cb (SkDisk                           *d,
                const SkSmartAttributeParsedData *a,
@@ -437,7 +440,10 @@ selftest_status_to_string (SkSmartSelfTestExecutionStatus status)
     }
   return ret;
 }
+#endif
 
+
+#ifdef HAVE_ATA_SMART
 static gboolean update_io_stats (UDisksLinuxDriveAta *drive, UDisksLinuxDevice *device)
 {
   const gchar *drivepath = g_udev_device_get_sysfs_path (device->udev_device);
@@ -469,6 +475,7 @@ static gboolean update_io_stats (UDisksLinuxDriveAta *drive, UDisksLinuxDevice *
     }
   return noio;
 }
+#endif
 
 /**
  * udisks_linux_drive_ata_refresh_smart_sync:
@@ -499,6 +506,7 @@ udisks_linux_drive_ata_refresh_smart_sync (UDisksLinuxDriveAta  *drive,
                                            GCancellable         *cancellable,
                                            GError              **error)
 {
+#ifdef HAVE_ATA_SMART
   UDisksLinuxDriveObject *object;
   UDisksLinuxDevice *device = NULL;
   gboolean ret = FALSE;
@@ -665,6 +673,9 @@ udisks_linux_drive_ata_refresh_smart_sync (UDisksLinuxDriveAta  *drive,
     sk_disk_free (d);
   g_clear_object (&object);
   return ret;
+#else
+  return FALSE;
+#endif
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
@@ -691,6 +702,7 @@ udisks_linux_drive_ata_smart_selftest_sync (UDisksLinuxDriveAta  *drive,
                                             GCancellable         *cancellable,
                                             GError              **error)
 {
+#ifdef HAVE_ATA_SMART
   UDisksLinuxDriveObject  *object;
   UDisksLinuxDevice *device = NULL;
   SkDisk *d = NULL;
@@ -752,6 +764,9 @@ udisks_linux_drive_ata_smart_selftest_sync (UDisksLinuxDriveAta  *drive,
     sk_disk_free (d);
   g_clear_object (&object);
   return ret;
+#else
+  return FALSE;
+#endif
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
